#####学习笔记
实战位运算要点

判断奇偶：
    
    x%2==1 --> (x&1) == 1
    x%2==0 --> (x&1) == 0
    x >> 1 --> x / 2
    x = x&(x-1)清零最低位的1，可用于判断是否是2的次幂，移除最低位1和自己比较是否为0；
    x&-x => 得到最低位的1
    x&~x => 0
 
 
#####Bloom Filter vs Hash Table

一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。

优点是空间效率和查询时间都远远超过一般的算法。

缺点是有一定的误识别率和删除困难。

挡在机器查询前的缓存，真正的数据还是得访问这个机器里面的数据库获得。

#####LRU Cache

两个要素：大小、替换策略。least recently used 最近最少使用会排名靠后，直至被淘汰。

HashTable + Double linkedList

O(1)查询

O(1) 修改、更新

####排序算法
1.比较类排序：

通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn),因此也称为非线性时间比较类排序。

2.非比较类排序：

不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。

####初级排序
1.选择排序：
  每次找最小值，然后放到待排序数组的起始位置。
  
2.插入排序：从前到后逐步构建有序序列；对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。

3.冒泡排序：嵌套排序，每次查看相邻的元素如果逆序，则交换。

####高级排序
快速排序：数组取标杆pivot，将小元素放pivot左边，大元素放右侧，然后依次对右边和右边的子数组继续快排；以达到整个序列有序。

归并排序：

1.把长度为n的输入序列分成两个长度为n/2的子序列；

2.对这两个子序列分别采用归并排序；

3.将两个排序好的子序列合并成一个最终的排序序列；

